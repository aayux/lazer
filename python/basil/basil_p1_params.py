from math import log, ceil, sqrt

# Create a header file with proof system parameters for
# proving knowledge of a witness s in Rp^n (Rp = Zp[X]/(X^d + 1))
# such that
#
#   1. s satisfies a linear relation over Rp: As + t = 0
#   2. each element in a partition of s either ..
#      2.1 has binary coefficients only
#      2.2 satisfies an l2-norm bound

vname = "p1_param"                                      # variable name

deg   = 512                                             # ring Rq degree d
mod   = 12289                                           # ring Rq modulus q
tau   = 3                                               # l-inf norm for encryption secrets
B     = 4                                               # batch size: number of messages
alpha = 2                                               # arity of the Merkle tree"
m     = 1                                               # dimension of the commited vectors
n     = ceil(m * log(mod, 2))                           # column dimension of L, R
dim   = (m + 3 * n + 8, 6 * n + 16)                     # dimension of A

# Decryption must hold for s, e1, e2 that can be as large as
# guaranteed by the ZK proof, i.e., 
# ||s e1 e2||_2 <= tau * sqrt(2 * n_ + 2 * m_)
# Independently, the sk eps1, eps2 is generated by the
# challenger and satisfies ||S1 S2||_oo <= tau.
# We must have || S1 * s + e2 - S2 * e1 ||_oo < p/2
# same for the randomness of c2
p = ceil(sqrt(2 * dim[1]) * tau ** 2 * sqrt(2 * dim[1] + 2 * dim[0]) + tau * sqrt(2 * dim[1] + 2 * dim[0]))

wpart = [   
            list(range(0, 16 + 3 * n)),                 # [ s e1 e2 ]
            list(range(16 + 3 * n, 16 + 6 * n)),        # [ h1 h2 h3 ]
    ]
wl2   = [ tau * sqrt(8 * deg), 0 ]  # l2-norm bounds
wbin  = [ 0, 1 ]                    # binary coeffs

# Optional: some linf-norm bound on x.
# Tighter bounds result in smaller proofs.
# If not specified, the default is the naive bound max(1,floor(max(wl2))).
# wlinf = 1

